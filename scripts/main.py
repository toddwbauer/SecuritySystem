import threading
import socket

from flask import Flask, render_template, Response

from data_logger import DataLogger
from pir import Pir
from webcam import WebcamController
from push import PushToPhone

# Title: Home Security System
#
# This program acts as a home security system for the user. It is used in
# conjunction with the .php files in the main folder to stream a live camera
# feed to a web server. Additionally, it allows users to record this footage
# to a local drive. It also detects motion using a PIR sensor, and when motion
# is detected, alerts the user via commandline, as well as pushing a
# notification to the user with a snapshot of the moment motion was detected.
#
# Authors: Todd Bauer, Gerardo Ortiz
# November 28, 2020

# Intialize Flask for broadcasting camera stream to the web server.
app = Flask(__name__)
PUSH_KEY = "fZf2wDKtvbvUIJJYPp8Q" # Unique device key registered with Pushsafer
PIR_PIN = 8                       # pin the PIR is connected to on Raspberry Pi
lock = threading.Lock()           # lock a thread to prevent concurrent behavior

# Reroutes to /video_feed for purposes of displaying camera stream.
@app.route("/")
def index():
    return render_template("index.html")

# Displays the video feed from the stream_video() function to the web server.
@app.route("/video_feed")
def video_feed():
    return Response(stream_video(),
        mimetype = "multipart/x-mixed-replace; boundary=frame")

###############################################################
# Generate a frame to use for recording and taking snapshots. #
###############################################################
def generate_video_frame():
    while True:
        
        # Lock the thread while a frame is generated.
        with lock:
            cam.generate_frame()

#######################################################
# Record each frame to video if recording is enabled. #
#######################################################
def record_video():
    recording_ongoing = False
    
    while True:
        # Given the way video recording is done with OpenCV; i.e., a video
        # writer object is created with a filename, then written to with
        # the write() function, we need a way to check if the recording is
        # just being initialized or is ongoing. If we don't do this, there
        # is no way to re-initialize a video with a new filename if the
        # user disables and then re-enables recording.
        if data_logger.video_log_enabled is True:
            if recording_ongoing is False:
                recording_ongoing = True
                with lock:
                    data_logger.start_recording()
            data_logger.video_to_file(cam.frame)
        else:
            if recording_ongoing is True:
                recording_ongoing = False
                with lock:
                    data_logger.stop_recording()

################################################################
# Detect motion from the PIR. If motion is detected, alert the #
# user - and if motion logging is enabled, save a picture of   #
# the event.                                                   #
################################################################
def detect_pir_motion():
    motion_is_ongoing = False
    
    while True:
        
        # Since we don't want to spam the user with pictures and messages
        # every time motion is detected, we use the motion_is_ongoing flag
        # to ensure that this is the first instance of motion in the
        # motion event. In the "else" statement, we use the same flag to
        # ensure the same thing for non-motion.
        # (Note that this is similar to flag system set up for video
        # recording in generate_video_frame())
        if pir.detect_motion() is True:
            if motion_is_ongoing is False:
                motion_is_ongoing = True
                print("Motion detected!")
                frame_as_base64 = push.encodeImage(cam.frame)
                
                # Uncomment this to send notification. Disabled for now to
                # prevent getting constant notifications during testing.
                #push.sendNot(frame_as_base64)
                
                # If motion logging is enabled, take a picture and send
                # a notification to the user. If not, alert the terminal.
                if data_logger.motion_log_enabled is True:
                    data_logger.motion_to_file(cam.frame)
                    
        else:
            if motion_is_ongoing is True:
                motion_is_ongoing = False
                print("Motion stopped.")

#############################################################################
# Streams the frames generated by generate_video_frame() to the web server. #
#############################################################################
def stream_video():
    while True:
        with lock:
            
            # Loop until there is a frame to stream.
            if cam.frame is None:
                continue
            
            # Encode the image to a streamable format.
            (flag, encodedImage) = cam.encode_as_jpg()
            if not flag:
                continue
            
        # stream the frame without breaking the while loop.
        yield(b'--frame\r\n' b'Content-Type: image/jpeg\r\n\r\n' + 
            bytearray(encodedImage) + b'\r\n')
    
##############################################################
# Returns the current IP of the Webcam the user is using.    #
##############################################################
def get_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(("8.8.8.8", 80))    
    local_ip = s.getsockname()[0]
    s.close()
    return local_ip

##################################################################
# Refreshes the settings so the program can update user settings #
# without requiring a restart.                                   #
##################################################################
def refresh_settings():
    while True:
        data_logger.refresh_settings()

###########################
# Main program execution. #
###########################
if __name__ == '__main__':
    # Set up the webcam. Since the program hinges on this device,
    # exit the program if the webcam cannot be found.
    try:
        cam = WebcamController(get_ip(), "8081")
    except Exception as e:
        print("Webcam server not found. Program stopped. Error message: ", e)
        exit(1)
    
    # Set up the PIR. As with the webcam, the PIR is vital to the program,
    # so we exit the program if the PIR is not found.
    try:
        pir = Pir(PIR_PIN)
        data_logger = DataLogger("../settings.txt")
    except Exception as e:
        print("PIR not found. Program stopped. Error message: ", e)
        exit(1)
        
    # Start the push notification service.
    push = PushToPhone(PUSH_KEY)
    
    # Start a thread to generate the camera frame every cycle.
    camThread = threading.Thread(target=generate_video_frame)
    camThread.daemon = True
    camThread.start()
    
    # Start a thread to detect motion every cycle.
    pirThread = threading.Thread(target=detect_pir_motion)
    pirThread.daemon = True
    pirThread.start()
    
    # Start a thread to refresh user settings every cycle.
    refreshThread = threading.Thread(target=refresh_settings)
    refreshThread.daemon = True
    refreshThread.start()
    
    # Start a thread to record generated frames to a video.
    refreshThread = threading.Thread(target=record_video)
    refreshThread.daemon = True
    refreshThread.start()

    # Start the service to stream the webcam footage to the web server.
    app.run(host=cam.ip, port=cam.port, debug=True,
            threaded=True, use_reloader=False)
    